# VXLAN (Virtual Extensible LAN)

VXLAN — Это технология overlay-сетей, которая инкапсулирует фрейм Ethernet в UDP-пакеты для передачи поверх IP-сети (underlay).\
VXLAN создает виртуальные L2-домены, не зависящие от физической топологии.

## Какие задачи решает?

1.	Преодоление лимита VLAN (4094): VXLAN использует 24-битный VNI (VXLAN Network Identifier), что дает ~16 миллионов изолированных сетей.
2.	Строительство L2-сетей поверх L3-фабрики: Позволяет "протягивать" L2-домены между любыми точками в IP-сети, что критично для виртуализации и DCI.
3.	Трафик между VTEP маршрутизируется по оптимальным L3-путям в underlay. За счет ECMP.

## Архитектура VXLAN

### Компоненты:
- VTEP (VXLAN Tunnel Endpoint) - конечная точка туннеля
- VNI (VXLAN Network Identifier) - идентификатор сети
- Underlay сеть - физическая транспортная сеть
- Overlay сеть - виртуальная сеть поверх underlay

### Формат пакета
Всегда немного отталкивает разбор пакетов, тем не менее на собеседованиях их иногда спрашивает, так что распишу чуть подробнее.

**Исходный пакет (до инкапсуляции):**
```aiignore
┌─────────────────────────────────────────┐
│         Original Ethernet Frame         │
├─────────────────────────────────────────┤
│ Destination MAC │ Source MAC │ VLAN Tag │
├─────────────────┼────────────┼──────────┤
│      6 bytes    │   6 bytes  │ 4 bytes  │
├─────────────────────────────────────────┤
│          Ethernet Payload               │
│        (IP packet, ARP, etc.)           │
└─────────────────────────────────────────┘
```
**После VXLAN инкапсуляции:**
```aiignore
┌───────────────────────────────────────────────────────────────────────────────────────────────┐
│                                  VXLAN Packet Structure                                       │
├─────────────┬────────────┬───────────┬───────────┬────────────────────────────────────────────┤
│ Outer Eth   │ Outer IP   │ Outer UDP │ VXLAN     │          Inner Ethernet                    │
│ Header      │ Header     │ Header    │ Header    │              Frame                         │
│ (14 bytes)  │ (20 bytes) │(8 bytes)  │(8 bytes)  │           (Original)                       │
├─────────────┼────────────┼───────────┼───────────┼────────────┬────────────┬──────────────────┤
│ Dst  │ Src  │ Src  │ Dst │ Src │ Dst │Flags│ VNI │   Dst MAC  │  Src MAC   │       Data       │
│ MAC  │ MAC  │ IP   │ IP  │ Port│ Port│     │     │            │            │                  │
│ 6B   │ 6B   │ 4B   │ 4B  │ 2B  │ 2B  │ 1B  │ 3B  │     6B     │    6B      │        ...       │
└─────────────┴────────────┴───────────┴───────────┴────────────┴────────────┴──────────────────┘
```
### Пошаговый процесс инкапсуляции

1. VM отправляет обычный Ethernet-кадр:
```aiignore
[Dest MAC: 00:50:56:01:02:03] [Src MAC: 00:50:56:04:05:06] [IP Packet...]
```
2. VTEP добавляет заголовки:
- Outer Ethernet Header
```aiignore
Destination MAC: MAC адрес следующего hop в underlay сети
Source MAC:      MAC адрес исходящего интерфейса VTEP
Ethertype:       0x0800 (IPv4)
```
- Outer IP Header
```aiignore
Source IP:      IP адрес исходного VTEP (например, 10.1.1.1)
Destination IP: IP адрес целевого VTEP (например, 10.1.1.2)
Protocol:       17 (UDP)
TTL:            255
```
- Outer UDP Header
```aiignore
Source Port:    Эфемерный порт (обычно hash от внутреннего кадра)
Destination Port: 4789 (стандартный порт VXLAN)
Length:         Размер UDP заголовка + VXLAN заголовка + исходного кадра
```
- VXLAN Header
```aiignore
Flags:          0x08 (00001000) - установлен бит I (Valid VNI)
Reserved:       0x000000 (24 бита)
VNI:            0x001234 (24 бита = 4660 в десятичной)
Reserved:       0x00 (8 бит)
```

Например, VM1 -> VM2 (внутри одного VNI), VMки подключены к разным VTEPам (192.168.1.10 и 192.168.1.20)

На VTEP1:
- Получает кадр от VM1: [MAC_DST][MAC_SRC][IP_PACKET]
- Определяет VNI, например, 10010
- Определяет целевой VTEP = 192.168.1.20
- Инкапсулирует:
```aiignore
[OUTER_ETHERNET: Next-hop MAC]
[OUTER_IP: SRC=192.168.1.10 DST=192.168.1.20]
[OUTER_UDP: SRC_PORT=54321 DST_PORT=4789]
[VXLAN: VNI=10010]
[ORIGINAL_ETHERNET_FRAME_FROM_VM1]
```
Маршрутизаторы передают пакет на основе Outer IP Header

На VTEP2:
- Получает пакет на порт 4789
- Проверяет VXLAN заголовок, извлекает VNI
- Декапсулирует - удаляет внешние заголовки
- Передает оригинальный кадр к VM2

## Ключевые поля в деталях

**VXLAN Header (8 байт)**:
```aiignore
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|R|R|R|R|I|R|R|R|            Reserved                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                VXLAN Network Identifier (VNI) |   Reserved    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
- Flags (8 бит):
  - Бит 3 (I): Valid VNI (всегда = 1 для валидных пакетов)
  - Остальные биты зарезервированы (= 0)
- VNI (24 бита): Виртуальный идентификатор сети (1-16777215)

**UDP Header особенности:**
- Source Port: Вычисляется на основе hash от внутреннего кадра 
- Destination Port: 4789 (стандарт) или 8472 (старый стандарт)
- UDP Checksum: Может быть = 0 (не проверяется)

**Overhead (дополнительные байты)**

Общий overhead = 50 байт:
- Outer Ethernet: 14 байт 
- Outer IP: 20 байт 
- Outer UDP: 8 байт 
- VXLAN Header: 8 байт

**Итого:** 14 + 20 + 8 + 8 = **50 байт**

Пример:
- Исходный кадр: 1500 байт 
- После инкапсуляции: 1550 байт 
- **_Требуется увеличение MTU!_**

## Что в итоге получаем?

_**Outer Ethernet:**_
Для передачи в underlay L2 сети

**_Outer IP:_**
Для маршрутизации между VTEP через IP сеть

**_Outer UDP:_**
Для демультиплексирования на целевом VTEP и балансировки нагрузки (ECMP)

**_VXLAN Header:_**
Для идентификации виртуальной сети (VNI)

_**Inner Ethernet:**_
Оригинальный кадр без изменений